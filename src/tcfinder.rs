use std::fs::File;
use std::io::prelude::*;
use std::io::{BufReader, SeekFrom};

use crypto::hmac::Hmac;
use crypto::pbkdf2;
use crypto::ripemd160::Ripemd160;

use xts;
use time;

use threadpool::ThreadPool;
use std::sync::mpsc::{self, Receiver};
use std::sync::Arc;

use pbr::ProgressBar;

use partitioninfo;

const BUFFER_SIZE: usize = 128*1024;

pub struct TCFinder {
    file: File
}

impl TCFinder {
    pub fn new(drive_path: &str) -> TCFinder {
        TCFinder {
            file: File::open(&drive_path).expect("Opening file failed!")
        }
    }
    
    pub fn scan(&mut self, sector_ranges: &[(u64, u64)], password: String) -> Vec<u64> {
        let info = partitioninfo::read_info_ntfs(&mut self.file).unwrap();
        println!("{}", info);

        // TODO: Test ranges: negative, > total sectors
        
        let sector_size: u64 = info.bytes_per_sector as u64;
        let job_count: usize = BUFFER_SIZE / sector_size as usize;


        let total_sectors_count = count_total_sectors(sector_ranges);
        let scan_start_time = time::precise_time_ns();

        let mut progressbar = ProgressBar::new(total_sectors_count);
        progressbar.format("╢▌▌░╟");

        // TODO: Fix this..
        let shared_password = Arc::new(password);
        
        let mut buf_reader = BufReader::with_capacity(BUFFER_SIZE, &self.file);
        // Buffer while reading data.
        let mut buf = [0u8; BUFFER_SIZE];

        // Vec of all potential headers.
        let mut found_sectors: Vec<u64> = Vec::new();

        let threadpool = ThreadPool::new(4);
        let (tx, rx) = mpsc::channel();

        for &(start_sector, end_sector) in sector_ranges {

            progressbar.message(&format!("[{}-{}]:  ", start_sector, end_sector));
            
            let start_bytes = start_sector * sector_size;
            buf_reader.seek(SeekFrom::Start(start_bytes)).expect("Seeking to start failed!");
            let mut i = start_sector;
            
            while i <= end_sector {
                {
                    buf_reader.read(&mut buf).expect("Filling buffer failed!");

                    let mut jobs = 0u8;

                    for j in 0..job_count {
                        // Sector range might not be multiple of buffer size. Break if over end_sector.
                        if i + j as u64 > end_sector {break;}


                        let pass = shared_password.clone();
                        jobs += 1;
                        let tx = tx.clone();
                        threadpool.execute(move || {
                            // Skip if 00 00 00 00 00 at start, unlikely to be a header.
                            if &buf[j*sector_size as usize..j*sector_size as usize + 5] == [0u8;5] {
                                tx.send(None).unwrap();
                                return;
                            }
                            
                            let mut hmac: Hmac<Ripemd160> = Hmac::new(Ripemd160::new(),
                                                                      pass.as_bytes());
                            // First 64 bytes of header is salt.
                            let salt = &buf[j*sector_size as usize..j*sector_size as usize +64];
                            // Only need first block (16 bytes) to decrypt magic bytes ("TRUE").
                            let header =
                                &buf[j*sector_size as usize + 64..
                                     j*sector_size as usize + 64 + 16];

                            let result = decrypt(&mut hmac, salt, header);

                            let found = &result[..4] == [0x54, 0x52, 0x55, 0x45];
                            if found {
                                tx.send(
                                    Some((i*sector_size, i + j as u64, arr_as_hex_str(&result)))
                                ).unwrap();
                                
                            } else {
                                tx.send(None).unwrap();
                            }
                        });

                        if jobs >= 32 {
                            collect_results(&rx, jobs, &mut progressbar, &mut found_sectors);
                            jobs = 0;
                        }
                    }

                    collect_results(&rx, jobs, &mut progressbar, &mut found_sectors);

                    buf_reader.consume(BUFFER_SIZE);
                    i += BUFFER_SIZE as u64 / 512;
                }
            }
        }

        let scan_end_time = time::precise_time_ns();
        println!("\nDone! Time: {}s", (scan_end_time - scan_start_time) / 1000000000);

        found_sectors
    }
}

fn decrypt(hmac: &mut Hmac<Ripemd160>, salt: &[u8], header: &[u8]) -> [u8; 16] {
    let mut header_keypool = [0u8; 64];
    pbkdf2::pbkdf2(hmac, salt, 2000, &mut header_keypool);
    let key1 = &header_keypool[..32];
    let key2 = &header_keypool[32..];
    xts::xts_decrypt(key1, key2, 0, header)
}

fn collect_results(rx: &Receiver<Option<(u64,u64,String)>>,
                   job_count: u8,
                   progressbar: &mut ProgressBar,
                   found_sectors: &mut Vec<u64>) {
    for _ in 0..job_count {
        match rx.recv().unwrap() {
            None => {},
            Some((a, b, c)) => {
                found_sectors.push(b);
                println!("\n\x1b\x5b1;32;1mFOUND: {} = {} LBA", a, b);
                println!("Decrypted: {}\x1b\x5b1;0m", c);
            }
        }
        progressbar.inc();
    }
}

fn arr_as_hex_str(arr: &[u8]) -> String {
    arr.iter().map(|b| format!("{:02X} ", b)).collect::<String>()
}

fn count_total_sectors(sector_ranges: &[(u64, u64)]) -> u64 {
    sector_ranges.iter().fold(0, |sum, &range| sum + (range.1 - range.0 + 1))
}


#[cfg(test)]
mod tests {
    use crypto::hmac::Hmac;
    use crypto::ripemd160::Ripemd160;
    use test::Bencher;

    const TC_HEADER: [u8; 512] =
        [0x3a, 0x6b, 0x85, 0xaf, 0x49, 0xc2, 0x40, 0x1b, 0x77, 0x21, 0x33, 0xc3, 0x31, 0x1b, 0xa8, 0xe9,
         0x1a, 0xe5, 0x78, 0x98, 0xf9, 0xae, 0x93, 0xb5, 0x70, 0x48, 0x49, 0x57, 0xbd, 0x32, 0x5c, 0x3f,
         0xf2, 0xc3, 0x8b, 0x8c, 0xf8, 0x34, 0x4b, 0xf9, 0x34, 0xfc, 0x58, 0xab, 0x49, 0xef, 0xb2, 0x6f,
         0xd7, 0x99, 0x09, 0xc1, 0x37, 0x4a, 0x99, 0xa4, 0xe4, 0xa4, 0x5f, 0xde, 0x5b, 0xa1, 0x2f, 0x3f,
         0x5d, 0x95, 0x5e, 0x96, 0x71, 0x22, 0x90, 0xb4, 0x85, 0x8c, 0xed, 0x0f, 0x88, 0x6c, 0x1d, 0xfc,
         0x68, 0x81, 0x01, 0x71, 0x14, 0xb2, 0xd4, 0xe9, 0x54, 0x37, 0xa5, 0xcc, 0xe2, 0x64, 0x57, 0x35,
         0x71, 0x9c, 0x82, 0x39, 0xe9, 0xd5, 0xaa, 0x0e, 0x84, 0x96, 0xfd, 0xba, 0x9b, 0xbd, 0xc8, 0x48,
         0xc3, 0x25, 0x9e, 0x16, 0x28, 0xa1, 0xa8, 0xdf, 0x5a, 0x1b, 0xa0, 0xe4, 0x68, 0x0c, 0xe4, 0xeb,
         0x6c, 0x9f, 0x16, 0x23, 0x78, 0x33, 0xb8, 0xc3, 0x88, 0xaf, 0xea, 0xe3, 0x6b, 0xd8, 0xa9, 0xea,
         0x08, 0xac, 0x9b, 0x51, 0x9a, 0x3b, 0x5e, 0x3f, 0x13, 0xc1, 0x12, 0x59, 0x97, 0xba, 0x14, 0xb8,
         0x37, 0x8f, 0x05, 0xc6, 0xf4, 0x15, 0xc2, 0x1b, 0x14, 0xc3, 0x6c, 0xc4, 0x04, 0x77, 0xb0, 0x85,
         0xc3, 0x58, 0x41, 0x92, 0x8d, 0xe2, 0x53, 0x0e, 0x68, 0x45, 0x65, 0x67, 0x8d, 0x4e, 0xf3, 0x2b,
         0x04, 0x99, 0x42, 0x57, 0x81, 0x4a, 0xc0, 0x16, 0x9f, 0xe5, 0xa9, 0x88, 0xef, 0x47, 0xd0, 0xc2,
         0x7d, 0x68, 0x47, 0x95, 0xb7, 0xfd, 0x88, 0xa0, 0xec, 0xc9, 0x57, 0x1f, 0xdb, 0xf4, 0xf3, 0x35,
         0x46, 0xd6, 0x66, 0xea, 0xc8, 0xe6, 0x85, 0x60, 0x96, 0x0a, 0xae, 0x1d, 0x2e, 0xa7, 0x5a, 0x1c,
         0x24, 0xf4, 0xd6, 0x72, 0x17, 0xd4, 0xa6, 0x40, 0x9a, 0xf9, 0xc3, 0x98, 0x58, 0x47, 0xc8, 0x3d,
         0xa4, 0x03, 0xd2, 0x00, 0xd5, 0x01, 0xdb, 0x22, 0x6e, 0x5e, 0xd8, 0x10, 0x94, 0x96, 0xf3, 0x5f,
         0x3a, 0x99, 0x33, 0x22, 0xea, 0x98, 0xe4, 0xa6, 0xd1, 0x84, 0xe2, 0x1f, 0xfe, 0x6e, 0x56, 0x77,
         0x41, 0xe6, 0x80, 0x45, 0xf5, 0x9e, 0x27, 0xef, 0xf7, 0x2a, 0x73, 0x70, 0x87, 0xdb, 0xd2, 0x86,
         0x76, 0x49, 0xf5, 0x11, 0xc0, 0xef, 0x93, 0x3b, 0x04, 0x95, 0xba, 0xab, 0x5e, 0x21, 0x8b, 0x27,
         0x92, 0xe0, 0x42, 0xb9, 0xb3, 0x1a, 0xf2, 0xfe, 0xfe, 0x60, 0x0b, 0x04, 0x8a, 0x96, 0xd1, 0xdd,
         0x22, 0xc5, 0x6c, 0x1d, 0x8d, 0x12, 0xb7, 0x6e, 0x16, 0x97, 0x66, 0x1f, 0x6c, 0x52, 0x5a, 0x94,
         0xaa, 0xb8, 0xb6, 0x81, 0xda, 0x07, 0x4d, 0x42, 0xc2, 0x82, 0x50, 0x04, 0x68, 0xcf, 0x81, 0xd9,
         0x3a, 0xc1, 0xc9, 0x0d, 0xa8, 0xc1, 0x68, 0xb4, 0x62, 0xb2, 0xa8, 0x0f, 0xef, 0xdf, 0x94, 0xb8,
         0xda, 0x4b, 0x29, 0xb1, 0xc0, 0x90, 0xa7, 0xbb, 0x1c, 0x02, 0xb4, 0x89, 0x52, 0x42, 0xa4, 0x04,
         0xfa, 0xcd, 0xee, 0x4e, 0xce, 0x4f, 0x1c, 0x0b, 0x9d, 0x6b, 0xd7, 0x16, 0xda, 0xa1, 0x6b, 0x23,
         0x6e, 0xdd, 0x40, 0x6c, 0xcc, 0xed, 0xa0, 0x6e, 0x0b, 0x22, 0x3b, 0x1e, 0x11, 0x2f, 0x42, 0x33,
         0x0b, 0x42, 0xd2, 0x34, 0x3e, 0x90, 0x44, 0x1b, 0x81, 0x3f, 0x5f, 0x6c, 0xde, 0xec, 0x31, 0x52,
         0x62, 0x33, 0x98, 0xeb, 0xb0, 0xd4, 0xfd, 0xc3, 0xe2, 0x1c, 0x31, 0xe8, 0x9c, 0x6b, 0x6f, 0x6f,
         0xdd, 0x8d, 0xa8, 0x8d, 0x48, 0x25, 0xc7, 0x07, 0x71, 0x4c, 0x92, 0xe4, 0xf6, 0x10, 0xb1, 0xad,
         0xf7, 0x22, 0xec, 0x10, 0x46, 0xc9, 0xf6, 0x1c, 0xf7, 0xc9, 0x4f, 0x14, 0xb4, 0xce, 0x07, 0x89,
         0xf4, 0x46, 0x58, 0xc5, 0x2f, 0xbb, 0x7b, 0x32, 0xa8, 0xe9, 0xd3, 0x18, 0x45, 0x3e, 0x1c, 0x0d];

    
    #[test]
    fn test_decrypt() {
        let password = "p4ssword";
        let mut hmac: Hmac<Ripemd160> = Hmac::new(Ripemd160::new(), password.as_bytes());
        let decrypted_bytes = super::decrypt(&mut hmac, &TC_HEADER[..64], &TC_HEADER[64..64 +16]);
        assert!(&decrypted_bytes[..4] == [0x54, 0x52, 0x55, 0x45]);
    }

    #[bench]
    fn test_decrypt_bench(b: &mut Bencher) {
        let password = "p4ssword";
        let mut hmac: Hmac<Ripemd160> = Hmac::new(Ripemd160::new(), password.as_bytes());
        b.iter(|| {super::decrypt(&mut hmac, &TC_HEADER[..64], &TC_HEADER[64..64 +16]);});
    }
}
